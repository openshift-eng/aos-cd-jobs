// poll-payload is a scheduled Jenkins job that polls payload changes on multiple release streams.
// NOTE: This job relies on workspace for keeping last retrieved state.

import groovy.transform.Field
import java.io.FileNotFoundException
import java.net.URLEncoder
import groovy.json.JsonOutput


@Field commonlib

// A map of release stream names to be polled and and actions to be taken
@Field final ACTIONS = [
    // as part of 4.next we will manually publish only sprintly dev-previews
    "4-dev-preview": [this.&setDevPreviewLatest],
    "4-dev-preview-s390x": [this.&setDevPreviewLatest],
    "4-dev-preview-ppc64le": [this.&setDevPreviewLatest],
    "4-dev-preview-arm64": [this.&setDevPreviewLatest],

    "4.12.0-0.nightly":  [this.&publishRPMs],
    // "4.12.0-0.nightly-s390x": this.&startPreReleaseJob,
    // "4.12.0-0.nightly-ppc64le": this.&startPreReleaseJob,
    // "4.12.0-0.nightly-arm64": this.&startPreReleaseJob,
    "4.12.0-0.nightly-multi": [this.&startPreReleaseJob],
    // 4.11 is not going to be released as a fc/rc named release, so
    // continue to publish as dev-preview until all 4.11 heterogeneous
    // users are using named releases.
    "4.11.0-0.nightly-multi": [this.&startPreReleaseJob],
]

def setDevPreviewLatest(String releaseStream, Map latestRelease, Map previousRelease) {
    def buildVersion = commonlib.extractMajorMinorVersion(releaseStream)
    def arch = commonlib.extractArchFromReleaseName(latestRelease.name)
    release.stageSetClientLatest(latestRelease.name, arch, "ocp-dev-preview")
}

def startPreReleaseJob(String releaseStream, Map latestRelease, Map previousRelease) {
    def buildVersion = commonlib.extractMajorMinorVersion(releaseStream)
    def arch = commonlib.extractArchFromReleaseName(latestRelease.name)
    build(
        job: '/aos-cd-builds/build%2Fpre-release',
        parameters: [
            string(name: 'BUILD_VERSION', value: buildVersion),
            string(name: 'ARCH', value: arch),
            string(name: 'FROM_RELEASE_TAG', value: latestRelease.name),
            booleanParam(name: 'MIRROR', value: true),
            booleanParam(name: 'SUPPRESS_EMAIL', value: true),
        ],
    )
}

def publishRPMs(String releaseStream, Map latestRelease, Map previousRelease) {
    build(
        job: '/aos-cd-builds/build%2Fpublish-rpms',
        parameters: [
            string(name: 'BUILD_VERSION', value: commonlib.extractMajorMinorVersion(releaseStream)),
        ],
    )
}

/**
 * Determine if the latest release has been changed
 * @param releaseStream release stream name
 * @param releaseCacheFile is a file to cache last checked release
 * @return [changed, latestRelease, previousRelease] If changed, changed is true.
 *     latestRelease is the metadata of the latest release,
*      and previousRelease is the metadata of the release checked last time.
 */
def checkLatestRelease(String releaseStream, String releaseCacheFile) {
    def encodedName = URLEncoder.encode(releaseStream, "UTF-8")
    def previousRelease = null
    try {
        previousRelease = readJSON(file: releaseCacheFile)
    } catch (FileNotFoundException ex) {
        echo "Cached previous release for $releaseStream is not found."
    }

    // There are different release controllers for OCP - one for each architecture.
    def release_controller_url = commonlib.getReleaseControllerURL(releaseStream)

    def url = "${release_controller_url}/api/v1/releasestream/${encodedName}/latest"
    def response = httpRequest(
        url: url,
        httpMode: 'GET',
        contentType: 'APPLICATION_JSON',
        timeout: 30,
    )
    def latestRelease = readJSON(text: response.content)
    def changed = !previousRelease || latestRelease.name != previousRelease.name
    return [changed, latestRelease, previousRelease]
}

def saveToReleaseCache(Map release, String releaseCacheFile) {
    writeFile(file: releaseCacheFile, text: JsonOutput.toJson(release))
}

properties([
    buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '30', numToKeepStr: '')),
    disableConcurrentBuilds(),
    disableResume(),
])

node() {
    checkout scm
    commonlib = load("pipeline-scripts/commonlib.groovy")
    description = ""
    def actionArguments = [:]
    if (ACTIONS.isEmpty()) {
        return
    }
    for (releaseStream in ACTIONS.keySet()) {
        def releaseCacheFile = "${releaseStream}.json"
        def changed, latestRelease, previousRelease
        try {
            (changed, latestRelease, previousRelease) = checkLatestRelease(releaseStream, releaseCacheFile)
            description += "${releaseStream} -> ${latestRelease.name}"
            if (!changed) {
                description += " [no change]\n"
                continue
            }
            actionArguments[releaseStream] = [releaseStream, latestRelease, previousRelease]
            saveToReleaseCache(latestRelease, "${releaseStream}.json")
        } catch (Exception ex) {
            echo "Error checking for latest release on $releaseStream: $ex"
            description += "${releaseStream} [error]\n"
            currentBuild.result = "UNSTABLE"
            continue
        }
        description += "\n"
    }
    currentBuild.description = description.trim()

    parallel(actionArguments.collectEntries({ releaseStream, args ->
        [releaseStream, {
            stage(releaseStream) {
                try {
                    echo "Invoking action for $releaseStream"
                    def action = ACTIONS[releaseStream]
                    if (action instanceof List) {
                        // If action is a list, invoke all functions one by one
                        for (fn in action) {
                            fn(args[0], args[1], args[2])
                        }
                    } else {
                        action(args[0], args[1], args[2])
                    }
                } catch (Exception ex) {
                    echo "Error invoking action for $releaseStream: $ex"
                    currentBuild.result = "UNSTABLE"
                }
            }
        }]
    }))
}
