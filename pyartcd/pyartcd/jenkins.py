
import logging
import os
import time
from enum import Enum
from typing import Optional

from jenkinsapi.jenkins import Jenkins
from jenkinsapi.queue import QueueItem
from jenkinsapi.build import Build
from jenkinsapi.utils.crumb_requester import CrumbRequester

from pyartcd import constants

logger = logging.getLogger(__name__)


class Jobs(Enum):
    BUILD_SYNC = 'aos-cd-builds/build%2Fbuild-sync'
    BUILD_MICROSHIFT = 'aos-cd-builds/build%2Fbuild-microshift'
    OCP4 = 'aos-cd-builds/build%2Focp4'
    RHCOS = 'aos-cd-builds/build%2Frhcos'
    OLM_BUNDLE = 'aos-cd-builds/build%2Folm_bundle'
    SYNC_FOR_CI = 'scheduled-builds/sync-for-ci'
    MICROSHIFT_SYNC = 'aos-cd-builds/build%2Fmicroshift_sync'


jenkins_client: Optional[Jenkins] = None


def init_jenkins():
    global jenkins_client
    if jenkins_client:
        return
    logger.info('Initializing Jenkins client..')
    requester = CrumbRequester(
        username=os.environ['JENKINS_SERVICE_ACCOUNT'],
        password=os.environ['JENKINS_SERVICE_ACCOUNT_TOKEN'],
        baseurl=constants.JENKINS_SERVER_URL
    )

    jenkins_client = Jenkins(
        constants.JENKINS_SERVER_URL,
        username=os.environ['JENKINS_SERVICE_ACCOUNT'],
        password=os.environ['JENKINS_SERVICE_ACCOUNT_TOKEN'],
        requester=requester,
        lazy=True
    )
    logger.info('Connected to Jenkins %s', jenkins_client.version)


def block_until_building(queue_item: QueueItem, delay: int = 5) -> str:
    """
    Watches a queue item and blocks until the scheduled build starts.

    Returns the URL of the new build.
    """

    while True:
        try:
            data: dict = queue_item.poll()
            build_number = data['executable']['number']
            break
        except (KeyError, TypeError):
            logger.info('Build not started yet, sleeping for %s seconds...', delay)
            time.sleep(delay)

    logger.info('Build started: number = %s', build_number)
    return f"{data['task']['url']}{build_number}"


def start_build(job_name: str, params: dict,
                block_until_building: bool = True,
                block_until_complete: bool = False,
                watch_building_delay: int = 5) -> Optional[str]:
    """
    Starts a new Jenkins build

    :param job_name: e.g. "aos-cd-builds/build%2Fbuild-sync"
    :param params: a key-value collection to be passed to the build
    :param block_until_building: True by default. Will block until the new build starts. This ensures
        triggered jobs are properly backlinked to parent jobs.
    :param block_until_complete: False by default. Will block until the new build completes
    :param watch_building_delay: Poll rate for building state

    Returns the build result if block_until_complete is True, None otherwise
    """

    init_jenkins()
    logger.info('Starting new build for job: %s', job_name)
    job = jenkins_client.get_job(job_name)
    queue_item = job.invoke(build_params=params)

    if not (block_until_building or block_until_complete):
        logger.info('Started new build for job: %s', job_name)
        return

    build_url = block_until_building(queue_item, watch_building_delay)
    logger.info('Started new build at %s', build_url)

    # Set build description to allow backlinking
    try:
        upstream_build_url = os.environ['BUILD_URL']
        job_name = os.environ['JOB_NAME']
    except KeyError:
        logger.error('BUILD_URL and JOB_NAME env vars must be defined!')
        raise

    upstream_build_number = list(filter(None, upstream_build_url.split('/')))[-1]
    build = Build(
        url=build_url.replace(constants.JENKINS_UI_URL, constants.JENKINS_SERVER_URL),
        buildno=int(build_url.split('/')[-1]),
        job=job
    )
    description = f'Started by upstream project <b>{job_name}</b> ' \
                  f'build number <a href="{upstream_build_url}">{upstream_build_number}</a><br><br>'
    build.job.jenkins.requester.post_and_confirm_status(
        f'{build.baseurl}/submitDescription',
        params={
            'Submit': 'submit',
            'description': description
        },
        data="",
        valid=[200]
    )

    if not block_until_complete:
        return None

    # Wait for the build to complete; get its status and return it
    logger.info('Waiting for build to complete...')
    build.block_until_complete()
    result = build.poll()['result']
    logger.info('Build completed with result: %s', result)
    return result


def start_ocp4(build_version: str, assembly: str, rpm_list: list = [],
               image_list: list = [], **kwargs) -> Optional[str]:
    params = {
        'BUILD_VERSION': build_version,
        'ASSEMBLY': assembly
    }

    # If any rpm/image changed, force a build with only changed sources
    if rpm_list or image_list:
        params['PIN_BUILDS'] = True

    # Build only changed RPMs or none
    if rpm_list:
        params['BUILD_RPMS'] = 'only'
        params['RPM_LIST'] = ','.join(rpm_list)
    else:
        params['BUILD_RPMS'] = 'none'

    # Build only changed images or none
    if image_list:
        params['BUILD_IMAGES'] = 'only'
        params['IMAGE_LIST'] = ','.join(image_list)
    else:
        params['BUILD_IMAGES'] = 'none'

    return start_build(
        job_name=Jobs.OCP4.value,
        params=params,
        **kwargs
    )


def start_rhcos(build_version: str, new_build: bool, **kwargs) -> Optional[str]:
    return start_build(
        job_name=Jobs.RHCOS.value,
        params={'BUILD_VERSION': build_version, 'NEW_BUILD': new_build},
        **kwargs
    )


def start_build_sync(build_version: str, assembly: str, doozer_data_path: Optional[str] = None,
                     doozer_data_gitref: Optional[str] = None, **kwargs) -> Optional[str]:
    params = {
        'BUILD_VERSION': build_version,
        'ASSEMBLY': assembly,
    }
    if doozer_data_path:
        params['DOOZER_DATA_PATH'] = doozer_data_path
    if doozer_data_gitref:
        params['DOOZER_DATA_GITREF'] = doozer_data_gitref

    return start_build(
        job_name=Jobs.BUILD_SYNC.value,
        params=params,
        **kwargs
    )


def start_build_microshift(build_version: str, assembly: str, dry_run: bool, **kwargs) -> Optional[str]:
    return start_build(
        job_name=Jobs.BUILD_MICROSHIFT.value,
        params={
            'BUILD_VERSION': build_version,
            'ASSEMBLY': assembly,
            'DRY_RUN': dry_run
        },
        **kwargs
    )


def start_olm_bundle(build_version: str, assembly: str, operator_nvrs: list,
                     doozer_data_path: str = constants.OCP_BUILD_DATA_URL,
                     doozer_data_gitref: str = '', **kwargs) -> Optional[str]:
    if not operator_nvrs:
        logger.warning('Empty operator NVR received: skipping olm-bundle')
        return

    return start_build(
        job_name=Jobs.OLM_BUNDLE.value,
        params={
            'BUILD_VERSION': build_version,
            'ASSEMBLY': assembly,
            'DOOZER_DATA_PATH': doozer_data_path,
            'DOOZER_DATA_GITREF': doozer_data_gitref,
            'OPERATOR_NVRS': ','.join(operator_nvrs)
        },
        **kwargs
    )


def start_sync_for_ci(version: str, **kwargs):
    return start_build(
        job_name=Jobs.SYNC_FOR_CI.value,
        params={
            'ONLY_FOR_VERSION': version
        },
        **kwargs
    )


def start_microshift_sync(version: str, assembly: str, **kwargs):
    return start_build(
        job_name=Jobs.MICROSHIFT_SYNC.value,
        params={
            'BUILD_VERSION': version,
            'ASSEMBLY': assembly
        },
        **kwargs
    )
