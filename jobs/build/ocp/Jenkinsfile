#!/usr/bin/env groovy

// Expose properties for a parameterized build
properties(
        [
            [$class : 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '720']],
            [$class : 'ParametersDefinitionProperty',
          parameterDefinitions:
                  [
                          [$class: 'hudson.model.StringParameterDefinition', defaultValue: 'openshift-build-1', description: 'Jenkins agent node', name: 'TARGET_NODE'],
                          [$class: 'hudson.model.ChoiceParameterDefinition', choices: "git@github.com:openshift\ngit@github.com:jupierce\ngit@github.com:jupierce-aos-cd-bot\ngit@github.com:adammhaile-aos-cd-bot", defaultValue: 'git@github.com:openshift', description: 'Github base for repos', name: 'GITHUB_BASE'],
                          [$class: 'hudson.model.ChoiceParameterDefinition', choices: "openshift-bot\naos-cd-test\njupierce-aos-cd-bot\nadammhaile-aos-cd-bot", defaultValue: 'aos-cd-test', description: 'SSH credential id to use', name: 'SSH_KEY_ID'],
                          [$class: 'hudson.model.ChoiceParameterDefinition', choices: "3.7\n3.6\n3.5\n3.4\n3.3", defaultValue: '3.7', description: 'OCP Version to build', name: 'BUILD_VERSION'],
                          [$class: 'hudson.model.StringParameterDefinition', defaultValue: 'aos-devel@redhat.com, aos-qe@redhat.com,jupierce@redhat.com,smunilla@redhat.com,ahaile@redhat.com', description: 'Success Mailing List', name: 'MAIL_LIST_SUCCESS'],
                          [$class: 'hudson.model.StringParameterDefinition', defaultValue: 'jupierce@redhat.com,smunilla@redhat.com,ahaile@redhat.com', description: 'Failure Mailing List', name: 'MAIL_LIST_FAILURE'],
                          [$class: 'hudson.model.ChoiceParameterDefinition', choices: "release\npre-release\nonline:int\nonline:stg", description:
'''
release                   {ose,origin-web-console,openshift-ansible}/release-X.Y ->  https://mirror.openshift.com/enterprise/enterprise-X.Y/latest/<br>
pre-release               {origin,origin-web-console,openshift-ansible}/release-X.Y ->  https://mirror.openshift.com/enterprise/enterprise-X.Y/latest/<br>
online:int                {origin,origin-web-console,openshift-ansible}/master -> online-int yum repo<br>
online:stg                {origin,origin-web-console,openshift-ansible}/stage -> online-stg yum repo<br>
''', name: 'BUILD_MODE'],
                          [$class: 'hudson.model.BooleanParameterDefinition', defaultValue: true, description: 'Sign RPMs with openshifthosted?', name: 'SIGN'],
                          [$class: 'hudson.model.BooleanParameterDefinition', defaultValue: false, description: 'Mock run to pickup new Jenkins parameters?', name: 'MOCK'],
                          [$class: 'hudson.model.BooleanParameterDefinition', defaultValue: false, description: 'Run as much code as possible without pushing / building?', name: 'TEST'],
                          [$class: 'hudson.model.TextParameterDefinition', defaultValue: "", description: 'Include special notes in the build email?', name: 'SPECIAL_NOTES'],
                  ]
            ],
            disableConcurrentBuilds()
        ]
)

IS_TEST_MODE = TEST.toBoolean()
BUILD_VERSION_MAJOR = BUILD_VERSION.tokenize('.')[0].toInteger() // Store the "X" in X.Y
BUILD_VERSION_MINOR = BUILD_VERSION.tokenize('.')[1].toInteger() // Store the "Y" in X.Y
SIGN_RPMS = SIGN.toBoolean()

def mail_success( version ) {

    def target = "(Release Candidate)"
    def mirrorURL = "https://mirror.openshift.com/enterprise/enterprise-${version.substring(0,3)}"

    if ( BUILD_MODE == "online:int" ) {
        target = "(Integration Testing)"
        mirrorURL = "https://mirror.openshift.com/enterprise/online-int"
    }

    if ( BUILD_MODE == "online:stg" ) {
        target = "(Stage Testing)"
        mirrorURL = "https://mirror.openshift.com/enterprise/online-stg"
    }

    def inject_notes = ""
    if ( SPECIAL_NOTES.trim() != "" ) {
        inject_notes = "\n***Special notes associated with this build****\n${SPECIAL_NOTES.trim()}\n***********************************************\n"
    }

    //IMG_SUCCESSES
    //IMG_FAILURES

    img_fail_msg = ""
    img_success_msg = """
===Successful Image Builds===
${IMG_SUCCESSES.join('\n')}\n
    """

    if(IMG_FAILURES.size() == 0) {
      mail_subject = "[aos-devel] New build for OpenShift ${target}: ${version}"
    }
    else {
      mail_subject = "[aos-devel] Partial build for OpenShift ${target}: ${version}"
      img_fail_msg = """
===Failed Image Builds===
${IMG_FAILURES.join('\n')}\n
      """
    }

    mail(
            to: "${MAIL_LIST_SUCCESS}",
            from: "aos-cd@redhat.com",
            replyTo: 'smunilla@redhat.com',
            subject: "${mail_subject}",
            body: """\
OpenShift Version: v${version}
${inject_notes}
Puddle (internal): http://download-node-02.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/AtomicOpenShift/${version.substring(0,3)}/${OCP_PUDDLE}
  - Mirror: ${mirrorURL}/${OCP_PUDDLE}
  - Images have been built for this puddle
  - Images have been pushed to registry.reg-aws.openshift.com:443
  - Images have been pushed to registry.ops

Brew:
  - Openshift: ${OSE_BREW_URL}
  - OpenShift Ansible: ${OA_BREW_URL}

Jenkins job: ${env.BUILD_URL}

${img_fail_msg}
${img_success_msg}

===Atomic OpenShift changelog snippet===
${OSE_CHANGELOG}

===OpenShift Ansible changelog snippet===
${OA_CHANGELOG}
""");
}


node(TARGET_NODE) {

    checkout scm
    AOS_CD_JOBS_COMMIT_SHA = sh(
            returnStdout: true,
            script: "git rev-parse HEAD",
    ).trim()

    PUDDLE_CONF_BASE="https://raw.githubusercontent.com/openshift/aos-cd-jobs/${AOS_CD_JOBS_COMMIT_SHA}/build-scripts/puddle-conf"
    PUDDLE_CONF="${PUDDLE_CONF_BASE}/atomic_openshift-${BUILD_VERSION}.conf"
    PUDDLE_SIGN_KEYS = SIGN_RPMS?"b906ba72":null

    def commonlib = load( "pipeline-scripts/commonlib.groovy")
    commonlib.initialize()

    try {
        sshagent([SSH_KEY_ID]) { // To work on real repos, buildlib operations must run with the permissions of openshift-bot

            def buildlib = load( "pipeline-scripts/buildlib.groovy")
            buildlib.initialize()
            echo "Initializing build: #${currentBuild.number} - ${BUILD_VERSION}.?? (${BUILD_MODE})"

            stage( "ose repo" ) {
                master_spec = buildlib.initialize_ose()
            }

            stage( "origin-web-console repo" ) {
                sh "go get github.com/jteeuwen/go-bindata"
                buildlib.initialize_origin_web_console()
                dir( WEB_CONSOLE_DIR ) {
                    // Enable fake merge driver used in our .gitattributes
                    sh "git config merge.ours.driver true"
                    // Use fake merge driver on specific directories
                    // We will be re-generating the dist directory, so ignore it for the merge
                    sh "echo 'dist/** merge=ours' >> .gitattributes"
                }
            }

            stage( "openshift-ansible repo" ) {
                buildlib.initialize_openshift_ansible()
            }

            stage( "analyze" ) {

                dir ( env.OSE_DIR ) {

                    // If the target version resides in ose#master
                    IS_SOURCE_IN_MASTER = ( BUILD_VERSION == master_spec.major_minor )

                    if ( IS_SOURCE_IN_MASTER ) {
                        if ( BUILD_MODE == "release" ) {
                            error( "You cannot build a release while it resides in master; cut an enterprise branch" )
                        }
                    } else {
                        if ( BUILD_MODE != "release" && BUILD_MODE != "pre-release" ) {
                            error( "Invlaid build mode for a releaes that does not reside in master: ${BUILD_MODE}" )
                        }
                    }

                    if ( IS_SOURCE_IN_MASTER ) {
                        OSE_SOURCE_BRANCH = "master"
                        UPSTREAM_SOURCE_BRANCH = "upstream/master"
                    } else {
                        OSE_SOURCE_BRANCH = "enterprise-${BUILD_VERSION}"
                        if ( BUILD_MODE == "release" ) {
                            // When building in release mode, no longer pull from upstream
                            UPSTREAM_SOURCE_BRANCH = null
                        } else {
                            UPSTREAM_SOURCE_BRANCH = "upstream/release-${BUILD_VERSION}"
                        }
                        // Create the non-master source branch and have it track the origin ose repo
                        sh "git checkout -b ${OSE_SOURCE_BRANCH} origin/${OSE_SOURCE_BRANCH}"
                    }

                    echo "Building from ose branch: ${OSE_SOURCE_BRANCH}"

                    spec = buildlib.read_spec_info("origin.spec")
                    rel_fields = spec.release.tokenize(".")


                    if ( BUILD_MODE == "online:int" || BUILD_MODE == "online:stg" ) {
                        /**
                         * In non-release candidates, we need the following fields
                         *      REL.INT.STG
                         * REL = 0    means pre-release,  1 means release
                         * INT = fields used to differentiate online:int builds
                         * STG = fields used to differentiate online:stg builds
                         */

                        while ( rel_fields.size() < 3 ) {
                            rel_fields << "0"    // Ensure there are enough fields in the array
                        }

                        if ( rel_fields[0].toInteger() != 0 ) {
                            // Don't build release candidate images this way since they can't wind up
                            // in registry.access with a tag OCP can pull.
                            error( "Do not build released products in ${BUILD_MODE}; just build in release or pre-release mode" )
                        }

                        if ( rel_fields.size() != 3 ) { // Did we start with > 3? That's too weird to continue
                            error( "Unexpected number of fields in release: ${spec.release}" )
                        }

                        if ( BUILD_MODE == "online:int" ) {
                            rel_fields[1] = rel_fields[1].toInteger() + 1  // Bump the INT version
                            rel_fields[2] = 0  // If we are bumping the INT field, everything following is reset to zero
                        }

                        if ( BUILD_MODE == "online:stg" ) {
                            rel_fields[2] = rel_fields[2].toInteger() + 1  // Bump the STG version
                        }

                        NEW_VERSION = spec.version   // Keep the existing spec's version
                        NEW_RELEASE = "${rel_fields[0]}.${rel_fields[1]}.${rel_fields[2]}"

                        // Add a bumpable field for ose_images.sh to increment for image refreshes (i.e. REL.INT.STG.BUMP)
                        NEW_DOCKERFILE_RELEASE = "${NEW_RELEASE}.0"

                    } else if ( BUILD_MODE == "release" || BUILD_MODE == "pre-release" ) {

                        /**
                         * Once someone sets the origin.spec Release to 1, we are building release candidates.
                         * If a release candidate is released, its associated images will show up in registry.access
                         * with the tags X.Y.Z-R  and  X.Y.Z. The "R" cannot be used since the fields is bumped by
                         * refresh-images when building images with signed RPMs. That is, if OCP tried to load images
                         * with the X.Y.Z-R' its RPM was built with, the R != R' (since R' < R) and the image
                         * would not be found.
                         * For release candidates, therefore, we must only use X.Y.Z to differentiate builds.
                         *
                         * Note that this problem does not affect online:int & online:stg builds since we control the
                         * tags in the registries. We have refresh-images bump a harmless field in the release and then
                         * craft a tag in the registry [version]-[release] which does not include that bumped field.
                         */
                        if ( rel_fields[0].toInteger() != 1 ) {
                            error( "You need to set the spec Release field to 1 in order to build in this mode" )
                        }

                        // Undertake to increment the last field in the version (e.g. 3.7.0 -> 3.7.1)
                        ver_fields = spec.version.tokenize(".")
                        ver_fields[ver_fields.size()-1] = "${ver_fields[ver_fields.size()-1].toInteger() + 1}"
                        NEW_VERSION = ver_fields.join(".")
                        NEW_DOCKERFILE_RELEASE = NEW_RELEASE = "1"

                    } else {
                        error( "Unknown BUILD_MODE: ${BUILD_MODE}" )
                    }

                    currentBuild.displayName = "#${currentBuild.number} - ${NEW_VERSION}-${NEW_RELEASE} (${BUILD_MODE})"

                }
            }

            stage( "prep web-console" ) {
                dir( WEB_CONSOLE_DIR ) {
                    // Unless building for stage, origin-web-console#entperise-X.Y should be used
                    if ( BUILD_MODE == "online:stg" ) {
                        WEB_CONSOLE_BRANCH = "stage"
                        sh "git checkout -b stage origin/stage"
                    } else {
                        WEB_CONSOLE_BRANCH = "enterprise-${spec.major_minor}"
                        sh "git checkout -b ${WEB_CONSOLE_BRANCH} origin/${WEB_CONSOLE_BRANCH}"
                        if ( IS_SOURCE_IN_MASTER ) {
                            sh """
                                # Pull content of master into enterprise branch
                                git merge master --no-commit --no-ff
                                # Use grunt to rebuild everything in the dist directory
                                ./hack/install-deps.sh
                                grunt build

                                git add dist
                                git commit -m "Merge master into enterprise-${BUILD_VERSION}" --allow-empty
                            """

                            if ( ! IS_TEST_MODE ) {
                                sh "git push"
                            }

                            // Clean up any unstaged changes (e.g. .gitattributes)
                            sh "git reset --hard HEAD"
                        }
                    }
                }
            }

            stage( "merge origin" ) {
                dir( OSE_DIR ) {
                    // Enable fake merge driver used in our .gitattributes
                    sh "git config merge.ours.driver true"
                    // Use fake merge driver on specific packages
                    sh "echo 'pkg/assets/bindata.go merge=ours' >> .gitattributes"
                    sh "echo 'pkg/assets/java/bindata.go merge=ours' >> .gitattributes"

                    if ( UPSTREAM_SOURCE_BRANCH != null ) {
                        // Merge upstream origin code into the ose branch
                        sh "git merge -m 'Merge remote-tracking branch ${UPSTREAM_SOURCE_BRANCH}' ${UPSTREAM_SOURCE_BRANCH}"
                    } else {
                        echo "No origin upstream in this build"
                    }
                }
            }

            stage( "merge web-console" ) {
                dir( OSE_DIR ) {

                    // Vendor a particular branch of the web console into our ose branch and capture the SHA we vendored in
                    // TODO: Is this necessary? If we don't specify a GIT_REF, will it just use the current branch
                    // we already setup?
                    // TODO: Easier way to get the VC_COMMIT by just using parse-rev when we checkout the desired web console branch?
                    VC_COMMIT = sh(
                            returnStdout: true,
                            script: "GIT_REF=${WEB_CONSOLE_BRANCH} hack/vendor-console.sh 2>/dev/null | grep 'Vendoring origin-web-console' | awk '{print \$4}'",
                    ).trim()

                    // Vendoring the console will rebuild this assets, so add them to the ose commit
                    sh """
                        git add pkg/assets/bindata.go
                        git add pkg/assets/java/bindata.go
                    """
                }
            }

            stage( "ose tag" ) {
                dir( OSE_DIR ) {
                    // Set the new release value in the file and tell tito to keep the version & release in the spec.
                    buildlib.set_rpm_spec_release_prefix( "origin.spec", NEW_RELEASE )
                    // Note that I did not use --use-release because it did not maintain variables like %{?dist}
                    sh "tito tag --accept-auto-changelog --keep-version --debug"
                    if ( ! IS_TEST_MODE ) {
                        sh "git push"
                        sh "git push --tags"
                    }
                    OSE_CHANGELOG = buildlib.read_changelog( "origin.spec" )
                }
            }

            stage( "openshift-ansible prep" ) {
                dir( OPENSHIFT_ANSIBLE_DIR ) {
                    if ( BUILD_MODE == "online:stg" ) {
                        sh "git checkout -b stage origin/stage"
                    } else {
                        if ( ! IS_SOURCE_IN_MASTER ) {
                            // At 3.6, openshift-ansible switched from release-1.X to match 3.X release branches
                            if ( BUILD_VERSION_MAJOR == 3 && BUILD_VERSION_MINOR < 6 ) {
                                sh "git checkout -b release-1.${BUILD_VERSION_MINOR} origin/release-1.${BUILD_VERSION_MINOR}"
                            } else {
                                sh "git checkout -b release-${BUILD_VERSION} origin/release-${BUILD_VERSION}"
                            }
                        } else {
                           sh "git checkout master"
                        }
                    }
                }
            }

            stage( "openshift-ansible tag" ) {
                dir(OPENSHIFT_ANSIBLE_DIR) {
                    if ( BUILD_VERSION_MAJOR == 3 && BUILD_VERSION_MINOR < 6 ) {
                        // Use legacy versioning if < 3.6
                        sh "tito tag --debug --accept-auto-changelog"
                    } else {
                        // If >= 3.6, keep openshift-ansible in sync with OCP version
                        buildlib.set_rpm_spec_version( "openshift-ansible.spec", NEW_VERSION )
                        buildlib.set_rpm_spec_release_prefix( "openshift-ansible.spec", NEW_RELEASE )
                        // Note that I did not use --use-release because it did not maintain variables like %{?dist}
                        sh "tito tag --debug --accept-auto-changelog --keep-version --debug"
                    }

                    if ( ! IS_TEST_MODE ) {
                        sh "git push"
                        sh "git push --tags"
                    }
                    OA_CHANGELOG = buildlib.read_changelog( "openshift-ansible.spec" )
                }
            }

            if ( IS_TEST_MODE ) {
                error( "This is as far as the test process can proceed without triggering builds" )
            }

            stage( "rpm builds" ) {

                // Allow both brew builds to run at the same time

                dir( OSE_DIR ) {
                    OSE_TASK_ID = sh(   returnStdout: true,
                            script: "tito release --debug --yes --test aos-${BUILD_VERSION} | grep 'Created task:' | awk '{print \$3}'"
                    )
                    OSE_BREW_URL = "https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=${OSE_TASK_ID}"
                    echo "ose rpm brew task: ${OSE_BREW_URL}"
                }
                dir( OPENSHIFT_ANSIBLE_DIR ) {
                    OA_TASK_ID = sh(   returnStdout: true,
                            script: "tito release --debug --yes --test aos-${BUILD_VERSION} | grep 'Created task:' | awk '{print \$3}'"
                    )
                    OA_BREW_URL = "https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=${OA_TASK_ID}"
                    echo "openshift-ansible rpm brew task: ${OA_BREW_URL}"
                }

                // Watch the tasks to make sure they succeed. If one fails, make sure the user knows which one by providing the correct brew URL
                try {
                    sh "brew watch-task ${OSE_TASK_ID}"
                } catch ( ose_err ) {
                    echo "Error in ose build task: ${OSE_BREW_URL}"
                    throw ose_err
                }
                try {
                    sh "brew watch-task ${OA_TASK_ID}"
                } catch ( oa_err ) {
                    echo "Error in openshift-ansible build task: ${OA_BREW_URL}"
                    throw oa_err
                }
            }

            stage( "signing rpms" ) {
                if ( SIGN_RPMS ) {
                    sh "${env.WORKSPACE}/build-scripts/sign_rpms.sh rhaos-${BUILD_VERSION}-rhel-7-candidate openshifthosted"
                } else {
                    echo "RPM signing has been skipped..."
                }
            }

            stage( "puddle: ose 'building'" ) {
              buildlib.build_puddle(
                      PUDDLE_CONF,    // The puddle configuration file to use
                      PUDDLE_SIGN_KEYS, // openshifthosted key
                      "-b",   // do not fail if we are missing dependencies
                      "-d",   // print debug information
                      "-n",   // do not send an email for this puddle
                      "-s",   // do not create a "latest" link since this puddle is for building images
                      "--label=building"   // create a symlink named "building" for the puddle
              )
            }

            stage( "compare dist-git" ) {
                sh "ose_images.sh --user ocp-build compare_nodocker --branch rhaos-${BUILD_VERSION}-rhel-7 --group base"
            }

            stage( "update dist-git" ) {
                sh "ose_images.sh --user ocp-build update_docker --branch rhaos-${BUILD_VERSION}-rhel-7 --group base --force --release '${NEW_DOCKERFILE_RELEASE}' --version 'v${NEW_VERSION}'"
            }

            stage( "build images" ) {
                dir( temp=true ) {
                  // TODO: Create a dynamic .repo file pointing to the exact puddle we built instead of "building" so that we can run X.Y builds in parallel
                  PUDDLE_REPO = "http://download.lab.bos.redhat.com/rcm-guest/puddles/RHAOS/repos/aos-unsigned-building.repo"
                  def build_result = sh (
                    script: "ose_images.sh --user ocp-build build_container --branch rhaos-${BUILD_VERSION}-rhel-7 --workingdir ${pwd()} --group base --repo ${PUDDLE_REPO}"
                    returnStatus: true
                  ) > 0
                  def failed_list_file = "${pwd()}/logs/failed_image_list"
                  IMG_FAILURES = []
                  if(fileExists(failed_list_file)) {
                    def failed_image_list = readFile(failed_list_file)
                    IMG_FAILURES = failed_image_list.split("\\r?\\n");
                  }

                  def success_list_file = "${pwd()}/logs/success_image_list"
                  IMG_SUCCESSES = []
                  if(fileExists(success_list_file)){
                    def success_image_list = readFile(success_list_file)
                    IMG_SUCCESSES = success_image_list.split("\\r?\\n");
                  }

                  acceptable_to_fail = [
                    "logging-deployment-docker",
                    "logging-curator-docker",
                    "logging-auth-proxy-docker",
                    "logging-elasticsearch-docker",
                    "logging-fluentd-docker",
                    "logging-kibana-docker"
                  ]

                  if( ! build_result ){

                    if(IMG_FAILURES.size() == 0 && IMG_SUCCESSES.size() == 0){
                      error("ose_images.sh threw a fatal error while building images.")
                    }
                    if(IMG_FAILURES.size() > 0){
                      fails = []
                      for(String img: IMG_FAILURES){
                        if(!acceptable_to_fail.contains(img)){
                          fails.add(img)
                        }
                      }
                      if(fails.size() > 0){
                        msg = "The following images failed and one or more was required.\n"
                        msg = msg + IMG_FAILURES.join("\n")
                        error(msg)
                      }
                    }
                  }
              }
            }

            buildlib.puddle_status(
                    "AtomicOpenShift",    // Build Type
                    "${BUILD_VERSION}", // current build version
                    "BUILDING",   // status.txt value
                    true,   // symlink latest
            )

            stage( "push images" ) {
                dir( "${env.WORKSPACE}/build-scripts/ose_images" ) {
                    TAG_LATEST = IS_SOURCE_IN_MASTER?"":"--nolatest"
                    sh "sudo ./ose_images.sh --user ocp-build push_images ${TAG_LATEST} --branch rhaos-${BUILD_VERSION}-rhel-7 --group base"
                    sh "sudo ./ose_images.sh --user ocp-build push_images ${TAG_LATEST} --branch rhaos-${BUILD_VERSION}-rhel-7 --group base --push_reg registry.reg-aws.openshift.com:443"
                }
            }

            buildlib.puddle_status(
                    "AtomicOpenShift",    // Build Type
                    "${BUILD_VERSION}", // current build version
                    "COMPLETE",   // status.txt value
                    false,   // symlink latest
            )

            echo "Created puddle on rcm-guest: /mnt/rcm-guest/puddles/RHAOS/AtomicOpenShift/${BUILD_VERSION}/${OCP_PUDDLE}"

            // Push the latest puddle out to the correct directory on the mirrors (e.g. online-int, online-stg, or enterprise-X.Y)
            buildlib.invoke_on_rcm_guest( "push-to-mirrors.sh", "simple", BUILD_VERSION, BUILD_MODE )

            NEW_FULL_VERSION="${NEW_VERSION}-${NEW_RELEASE}"

            if ( NEW_RELEASE != "1" ) {
                // If this is not a release candidate, push binary in a directory qualified with release field information
                buildlib.invoke_on_rcm_guest( "publish-oc-binary.sh", BUILD_VERSION, NEW_FULL_VERSION )
            } else {
                // If this is a release candidate, the directory binary directory should not contain release information
                buildlib.invoke_on_rcm_guest( "publish-oc-binary.sh", BUILD_VERSION, NEW_VERSION )
            }

            echo "Finished building OCP ${NEW_FULL_VERSION}"

            mail_success( NEW_FULL_VERSION )
        }
    } catch ( err ) {
        mail(to: "${MAIL_LIST_FAILURE}",
                from: "aos-cd@redhat.com",
                subject: "Error building OSE: ${BUILD_VERSION}",
                body: """Encountered an error while running OCP pipeline: ${err}

    Jenkins job: ${env.BUILD_URL}
    """);
        throw err
    }


}
